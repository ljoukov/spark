// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SparkProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum SparkUploadTypeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case photo // = 1
  case pdfFull // = 2
  case pdfPageRange // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .photo
    case 2: self = .pdfFull
    case 3: self = .pdfPageRange
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .photo: return 1
    case .pdfFull: return 2
    case .pdfPageRange: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SparkUploadTypeProto] = [
    .undefined,
    .photo,
    .pdfFull,
    .pdfPageRange,
  ]

}

public enum SparkAnswerGradeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case correct // = 1
  case incorrect // = 2
  case partial // = 3
  case retry // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .correct
    case 2: self = .incorrect
    case 3: self = .partial
    case 4: self = .retry
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .correct: return 1
    case .incorrect: return 2
    case .partial: return 3
    case .retry: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SparkAnswerGradeProto] = [
    .undefined,
    .correct,
    .incorrect,
    .partial,
    .retry,
  ]

}

public enum SparkQuestionKindProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case multipleChoice // = 1
  case trueFalse // = 2
  case shortText // = 3
  case numeric // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .multipleChoice
    case 2: self = .trueFalse
    case 3: self = .shortText
    case 4: self = .numeric
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .multipleChoice: return 1
    case .trueFalse: return 2
    case .shortText: return 3
    case .numeric: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SparkQuestionKindProto] = [
    .undefined,
    .multipleChoice,
    .trueFalse,
    .shortText,
    .numeric,
  ]

}

public enum SparkNumericToleranceTypeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case absolute // = 1
  case relative // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .absolute
    case 2: self = .relative
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .absolute: return 1
    case .relative: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SparkNumericToleranceTypeProto] = [
    .undefined,
    .absolute,
    .relative,
  ]

}

public enum SparkProgrammeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case gcseTripleScience // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .gcseTripleScience
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .gcseTripleScience: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SparkProgrammeProto] = [
    .undefined,
    .gcseTripleScience,
  ]

}

public enum SparkSubjectProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case biology // = 1
  case chemistry // = 2
  case physics // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .biology
    case 2: self = .chemistry
    case 3: self = .physics
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .biology: return 1
    case .chemistry: return 2
    case .physics: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SparkSubjectProto] = [
    .undefined,
    .biology,
    .chemistry,
    .physics,
  ]

}

public enum SparkExamBoardProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case aqa // = 1
  case edexcel // = 2
  case ocr // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .aqa
    case 2: self = .edexcel
    case 3: self = .ocr
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .aqa: return 1
    case .edexcel: return 2
    case .ocr: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SparkExamBoardProto] = [
    .undefined,
    .aqa,
    .edexcel,
    .ocr,
  ]

}

public enum SparkGenerationModeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case extraction // = 1
  case synthesis // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .extraction
    case 2: self = .synthesis
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .extraction: return 1
    case .synthesis: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SparkGenerationModeProto] = [
    .undefined,
    .extraction,
    .synthesis,
  ]

}

public enum SparkJobStateProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case received // = 1
  case processing // = 2
  case completed // = 3
  case failed // = 4
  case cancelled // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .received
    case 2: self = .processing
    case 3: self = .completed
    case 4: self = .failed
    case 5: self = .cancelled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .received: return 1
    case .processing: return 2
    case .completed: return 3
    case .failed: return 4
    case .cancelled: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SparkJobStateProto] = [
    .undefined,
    .received,
    .processing,
    .completed,
    .failed,
    .cancelled,
  ]

}

public enum SparkQuizStateStatusProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case notStarted // = 1
  case inProgress // = 2
  case completed // = 3
  case archived // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .notStarted
    case 2: self = .inProgress
    case 3: self = .completed
    case 4: self = .archived
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .notStarted: return 1
    case .inProgress: return 2
    case .completed: return 3
    case .archived: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SparkQuizStateStatusProto] = [
    .undefined,
    .notStarted,
    .inProgress,
    .completed,
    .archived,
  ]

}

public enum SparkQuizReviewStatusProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case notRequired // = 1
  case pending // = 2
  case inReview // = 3
  case done // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .notRequired
    case 2: self = .pending
    case 3: self = .inReview
    case 4: self = .done
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .notRequired: return 1
    case .pending: return 2
    case .inReview: return 3
    case .done: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SparkQuizReviewStatusProto] = [
    .undefined,
    .notRequired,
    .pending,
    .inReview,
    .done,
  ]

}

public struct SparkApiRequestProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestAuth: SparkRequestAuthProto {
    get {return _storage._requestAuth ?? SparkRequestAuthProto()}
    set {_uniqueStorage()._requestAuth = newValue}
  }
  /// Returns true if `requestAuth` has been explicitly set.
  public var hasRequestAuth: Bool {return _storage._requestAuth != nil}
  /// Clears the value of `requestAuth`. Subsequent reads from it will return its default value.
  public mutating func clearRequestAuth() {_uniqueStorage()._requestAuth = nil}

  public var clientContext: SparkClientContextProto {
    get {return _storage._clientContext ?? SparkClientContextProto()}
    set {_uniqueStorage()._clientContext = newValue}
  }
  /// Returns true if `clientContext` has been explicitly set.
  public var hasClientContext: Bool {return _storage._clientContext != nil}
  /// Clears the value of `clientContext`. Subsequent reads from it will return its default value.
  public mutating func clearClientContext() {_uniqueStorage()._clientContext = nil}

  public var request: OneOf_Request? {
    get {return _storage._request}
    set {_uniqueStorage()._request = newValue}
  }

  public var create: SparkCreateRequestProto {
    get {
      if case .create(let v)? = _storage._request {return v}
      return SparkCreateRequestProto()
    }
    set {_uniqueStorage()._request = .create(newValue)}
  }

  public var checkAnswer: SparkCheckAnswerRequestProto {
    get {
      if case .checkAnswer(let v)? = _storage._request {return v}
      return SparkCheckAnswerRequestProto()
    }
    set {_uniqueStorage()._request = .checkAnswer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    case create(SparkCreateRequestProto)
    case checkAnswer(SparkCheckAnswerRequestProto)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct SparkApiResponseProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: SparkApiErrorProto {
    get {return _error ?? SparkApiErrorProto()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var response: SparkApiResponseProto.OneOf_Response? = nil

  public var create: SparkCreateResponseProto {
    get {
      if case .create(let v)? = response {return v}
      return SparkCreateResponseProto()
    }
    set {response = .create(newValue)}
  }

  public var checkAnswer: SparkCheckAnswerResponseProto {
    get {
      if case .checkAnswer(let v)? = response {return v}
      return SparkCheckAnswerResponseProto()
    }
    set {response = .checkAnswer(newValue)}
  }

  public var latencies: Dictionary<String,SwiftProtobuf.Google_Protobuf_Duration> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable, Sendable {
    case create(SparkCreateResponseProto)
    case checkAnswer(SparkCheckAnswerResponseProto)

  }

  public init() {}

  fileprivate var _error: SparkApiErrorProto? = nil
}

public struct SparkCreateRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var upload: SparkUploadReferenceProto {
    get {return _upload ?? SparkUploadReferenceProto()}
    set {_upload = newValue}
  }
  /// Returns true if `upload` has been explicitly set.
  public var hasUpload: Bool {return self._upload != nil}
  /// Clears the value of `upload`. Subsequent reads from it will return its default value.
  public mutating func clearUpload() {self._upload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _upload: SparkUploadReferenceProto? = nil
}

public struct SparkCreateResponseProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var job: SparkJobStatusProto {
    get {return _storage._job ?? SparkJobStatusProto()}
    set {_uniqueStorage()._job = newValue}
  }
  /// Returns true if `job` has been explicitly set.
  public var hasJob: Bool {return _storage._job != nil}
  /// Clears the value of `job`. Subsequent reads from it will return its default value.
  public mutating func clearJob() {_uniqueStorage()._job = nil}

  public var quiz: SparkQuizProto {
    get {return _storage._quiz ?? SparkQuizProto()}
    set {_uniqueStorage()._quiz = newValue}
  }
  /// Returns true if `quiz` has been explicitly set.
  public var hasQuiz: Bool {return _storage._quiz != nil}
  /// Clears the value of `quiz`. Subsequent reads from it will return its default value.
  public mutating func clearQuiz() {_uniqueStorage()._quiz = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct SparkUploadReferenceProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storagePath: String = String()

  public var uploadType: SparkUploadTypeProto = .undefined

  public var mimeType: String = String()

  public var sizeBytes: Int64 = 0

  public var pageRange: SparkPageRangeProto {
    get {return _pageRange ?? SparkPageRangeProto()}
    set {_pageRange = newValue}
  }
  /// Returns true if `pageRange` has been explicitly set.
  public var hasPageRange: Bool {return self._pageRange != nil}
  /// Clears the value of `pageRange`. Subsequent reads from it will return its default value.
  public mutating func clearPageRange() {self._pageRange = nil}

  public var uploadedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _uploadedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uploadedAt = newValue}
  }
  /// Returns true if `uploadedAt` has been explicitly set.
  public var hasUploadedAt: Bool {return self._uploadedAt != nil}
  /// Clears the value of `uploadedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUploadedAt() {self._uploadedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pageRange: SparkPageRangeProto? = nil
  fileprivate var _uploadedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct SparkPageRangeProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startPage: Int32 = 0

  public var endPage: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkCheckAnswerRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var quizID: String = String()

  public var questionID: String = String()

  public var answer: SparkSubmittedAnswerProto {
    get {return _answer ?? SparkSubmittedAnswerProto()}
    set {_answer = newValue}
  }
  /// Returns true if `answer` has been explicitly set.
  public var hasAnswer: Bool {return self._answer != nil}
  /// Clears the value of `answer`. Subsequent reads from it will return its default value.
  public mutating func clearAnswer() {self._answer = nil}

  public var attemptID: String = String()

  public var answeredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _answeredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_answeredAt = newValue}
  }
  /// Returns true if `answeredAt` has been explicitly set.
  public var hasAnsweredAt: Bool {return self._answeredAt != nil}
  /// Clears the value of `answeredAt`. Subsequent reads from it will return its default value.
  public mutating func clearAnsweredAt() {self._answeredAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _answer: SparkSubmittedAnswerProto? = nil
  fileprivate var _answeredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct SparkCheckAnswerResponseProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var evaluation: SparkAnswerEvaluationProto {
    get {return _evaluation ?? SparkAnswerEvaluationProto()}
    set {_evaluation = newValue}
  }
  /// Returns true if `evaluation` has been explicitly set.
  public var hasEvaluation: Bool {return self._evaluation != nil}
  /// Clears the value of `evaluation`. Subsequent reads from it will return its default value.
  public mutating func clearEvaluation() {self._evaluation = nil}

  public var question: SparkQuestionProto {
    get {return _question ?? SparkQuestionProto()}
    set {_question = newValue}
  }
  /// Returns true if `question` has been explicitly set.
  public var hasQuestion: Bool {return self._question != nil}
  /// Clears the value of `question`. Subsequent reads from it will return its default value.
  public mutating func clearQuestion() {self._question = nil}

  public var evaluatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _evaluatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_evaluatedAt = newValue}
  }
  /// Returns true if `evaluatedAt` has been explicitly set.
  public var hasEvaluatedAt: Bool {return self._evaluatedAt != nil}
  /// Clears the value of `evaluatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearEvaluatedAt() {self._evaluatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _evaluation: SparkAnswerEvaluationProto? = nil
  fileprivate var _question: SparkQuestionProto? = nil
  fileprivate var _evaluatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct SparkSubmittedAnswerProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: SparkSubmittedAnswerProto.OneOf_Value? = nil

  public var text: String {
    get {
      if case .text(let v)? = value {return v}
      return String()
    }
    set {value = .text(newValue)}
  }

  public var optionID: String {
    get {
      if case .optionID(let v)? = value {return v}
      return String()
    }
    set {value = .optionID(newValue)}
  }

  public var trueFalse: Bool {
    get {
      if case .trueFalse(let v)? = value {return v}
      return false
    }
    set {value = .trueFalse(newValue)}
  }

  public var numeric: SparkNumericSubmissionProto {
    get {
      if case .numeric(let v)? = value {return v}
      return SparkNumericSubmissionProto()
    }
    set {value = .numeric(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable, Sendable {
    case text(String)
    case optionID(String)
    case trueFalse(Bool)
    case numeric(SparkNumericSubmissionProto)

  }

  public init() {}
}

public struct SparkNumericSubmissionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Double = 0

  public var unit: String = String()

  public var significantFigures: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkAnswerEvaluationProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var grade: SparkAnswerGradeProto = .undefined

  public var feedback: String = String()

  public var score: Double = 0

  public var retryAvailableAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _retryAvailableAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_retryAvailableAt = newValue}
  }
  /// Returns true if `retryAvailableAt` has been explicitly set.
  public var hasRetryAvailableAt: Bool {return self._retryAvailableAt != nil}
  /// Clears the value of `retryAvailableAt`. Subsequent reads from it will return its default value.
  public mutating func clearRetryAvailableAt() {self._retryAvailableAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _retryAvailableAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct SparkQuestionProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var questionID: String {
    get {return _storage._questionID}
    set {_uniqueStorage()._questionID = newValue}
  }

  public var kind: SparkQuestionKindProto {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  public var prompt: String {
    get {return _storage._prompt}
    set {_uniqueStorage()._prompt = newValue}
  }

  public var source: SparkQuestionSourceProto {
    get {return _storage._source ?? SparkQuestionSourceProto()}
    set {_uniqueStorage()._source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return _storage._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {_uniqueStorage()._source = nil}

  public var answerKey: SparkQuestionAnswerKeyProto {
    get {return _storage._answerKey ?? SparkQuestionAnswerKeyProto()}
    set {_uniqueStorage()._answerKey = newValue}
  }
  /// Returns true if `answerKey` has been explicitly set.
  public var hasAnswerKey: Bool {return _storage._answerKey != nil}
  /// Clears the value of `answerKey`. Subsequent reads from it will return its default value.
  public mutating func clearAnswerKey() {_uniqueStorage()._answerKey = nil}

  public var hints: [String] {
    get {return _storage._hints}
    set {_uniqueStorage()._hints = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var body: OneOf_Body? {
    get {return _storage._body}
    set {_uniqueStorage()._body = newValue}
  }

  public var multipleChoice: SparkMultipleChoiceQuestionProto {
    get {
      if case .multipleChoice(let v)? = _storage._body {return v}
      return SparkMultipleChoiceQuestionProto()
    }
    set {_uniqueStorage()._body = .multipleChoice(newValue)}
  }

  public var trueFalse: SparkTrueFalseQuestionProto {
    get {
      if case .trueFalse(let v)? = _storage._body {return v}
      return SparkTrueFalseQuestionProto()
    }
    set {_uniqueStorage()._body = .trueFalse(newValue)}
  }

  public var shortText: SparkFreeTextQuestionProto {
    get {
      if case .shortText(let v)? = _storage._body {return v}
      return SparkFreeTextQuestionProto()
    }
    set {_uniqueStorage()._body = .shortText(newValue)}
  }

  public var numeric: SparkNumericQuestionProto {
    get {
      if case .numeric(let v)? = _storage._body {return v}
      return SparkNumericQuestionProto()
    }
    set {_uniqueStorage()._body = .numeric(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    case multipleChoice(SparkMultipleChoiceQuestionProto)
    case trueFalse(SparkTrueFalseQuestionProto)
    case shortText(SparkFreeTextQuestionProto)
    case numeric(SparkNumericQuestionProto)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct SparkQuestionSourceProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uploadPath: String = String()

  public var pageRange: SparkPageRangeProto {
    get {return _pageRange ?? SparkPageRangeProto()}
    set {_pageRange = newValue}
  }
  /// Returns true if `pageRange` has been explicitly set.
  public var hasPageRange: Bool {return self._pageRange != nil}
  /// Clears the value of `pageRange`. Subsequent reads from it will return its default value.
  public mutating func clearPageRange() {self._pageRange = nil}

  public var snippet: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pageRange: SparkPageRangeProto? = nil
}

public struct SparkQuestionAnswerKeyProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: SparkQuestionAnswerKeyProto.OneOf_Key? = nil

  public var multipleChoice: SparkMultipleChoiceAnswerKeyProto {
    get {
      if case .multipleChoice(let v)? = key {return v}
      return SparkMultipleChoiceAnswerKeyProto()
    }
    set {key = .multipleChoice(newValue)}
  }

  public var trueFalse: SparkTrueFalseAnswerKeyProto {
    get {
      if case .trueFalse(let v)? = key {return v}
      return SparkTrueFalseAnswerKeyProto()
    }
    set {key = .trueFalse(newValue)}
  }

  public var shortText: SparkFreeTextAnswerKeyProto {
    get {
      if case .shortText(let v)? = key {return v}
      return SparkFreeTextAnswerKeyProto()
    }
    set {key = .shortText(newValue)}
  }

  public var numeric: SparkNumericAnswerKeyProto {
    get {
      if case .numeric(let v)? = key {return v}
      return SparkNumericAnswerKeyProto()
    }
    set {key = .numeric(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Key: Equatable, Sendable {
    case multipleChoice(SparkMultipleChoiceAnswerKeyProto)
    case trueFalse(SparkTrueFalseAnswerKeyProto)
    case shortText(SparkFreeTextAnswerKeyProto)
    case numeric(SparkNumericAnswerKeyProto)

  }

  public init() {}
}

public struct SparkMultipleChoiceQuestionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: [SparkMultipleChoiceOptionProto] = []

  public var shuffleOptions: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkMultipleChoiceOptionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var optionID: String = String()

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkTrueFalseQuestionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var statement: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkFreeTextQuestionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rubric: SparkFreeTextRubricProto {
    get {return _rubric ?? SparkFreeTextRubricProto()}
    set {_rubric = newValue}
  }
  /// Returns true if `rubric` has been explicitly set.
  public var hasRubric: Bool {return self._rubric != nil}
  /// Clears the value of `rubric`. Subsequent reads from it will return its default value.
  public mutating func clearRubric() {self._rubric = nil}

  public var keyPoints: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rubric: SparkFreeTextRubricProto? = nil
}

public struct SparkFreeTextRubricProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var overview: String = String()

  public var bulletPoints: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkNumericQuestionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var promptSuffix: String = String()

  public var rule: SparkNumericAnswerRuleProto {
    get {return _rule ?? SparkNumericAnswerRuleProto()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  public var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  public mutating func clearRule() {self._rule = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rule: SparkNumericAnswerRuleProto? = nil
}

public struct SparkNumericAnswerRuleProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Double = 0

  public var unit: String = String()

  public var toleranceType: SparkNumericToleranceTypeProto = .undefined

  public var tolerance: Double = 0

  public var significantFigures: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkMultipleChoiceAnswerKeyProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var correctOptionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkTrueFalseAnswerKeyProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var correctValue: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkFreeTextAnswerKeyProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exemplarAnswers: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkNumericAnswerKeyProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var expected: SparkNumericAnswerRuleProto {
    get {return _expected ?? SparkNumericAnswerRuleProto()}
    set {_expected = newValue}
  }
  /// Returns true if `expected` has been explicitly set.
  public var hasExpected: Bool {return self._expected != nil}
  /// Clears the value of `expected`. Subsequent reads from it will return its default value.
  public mutating func clearExpected() {self._expected = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expected: SparkNumericAnswerRuleProto? = nil
}

public struct SparkQuizProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var quizID: String = String()

  public var metadata: SparkQuizMetadataProto {
    get {return _metadata ?? SparkQuizMetadataProto()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var questions: [SparkQuestionProto] = []

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: SparkQuizMetadataProto? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct SparkQuizMetadataProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var programme: SparkProgrammeProto = .undefined

  public var subject: SparkSubjectProto = .undefined

  public var examBoard: SparkExamBoardProto = .undefined

  public var generationMode: SparkGenerationModeProto = .undefined

  public var totalQuestions: Int32 = 0

  public var topic: String = String()

  public var subtopic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkJobStatusProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jobID: String = String()

  public var state: SparkJobStateProto = .undefined

  public var progressPercent: Double = 0

  public var statusMessage: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var error: SparkJobErrorProto {
    get {return _error ?? SparkJobErrorProto()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _error: SparkJobErrorProto? = nil
}

public struct SparkJobErrorProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var message: String = String()

  public var context: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkFirestoreDocProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var docID: String {
    get {return _storage._docID}
    set {_uniqueStorage()._docID = newValue}
  }

  public var upload: SparkUploadReferenceProto {
    get {return _storage._upload ?? SparkUploadReferenceProto()}
    set {_uniqueStorage()._upload = newValue}
  }
  /// Returns true if `upload` has been explicitly set.
  public var hasUpload: Bool {return _storage._upload != nil}
  /// Clears the value of `upload`. Subsequent reads from it will return its default value.
  public mutating func clearUpload() {_uniqueStorage()._upload = nil}

  public var job: SparkJobStatusProto {
    get {return _storage._job ?? SparkJobStatusProto()}
    set {_uniqueStorage()._job = newValue}
  }
  /// Returns true if `job` has been explicitly set.
  public var hasJob: Bool {return _storage._job != nil}
  /// Clears the value of `job`. Subsequent reads from it will return its default value.
  public mutating func clearJob() {_uniqueStorage()._job = nil}

  public var quiz: SparkQuizProto {
    get {return _storage._quiz ?? SparkQuizProto()}
    set {_uniqueStorage()._quiz = newValue}
  }
  /// Returns true if `quiz` has been explicitly set.
  public var hasQuiz: Bool {return _storage._quiz != nil}
  /// Clears the value of `quiz`. Subsequent reads from it will return its default value.
  public mutating func clearQuiz() {_uniqueStorage()._quiz = nil}

  public var summary: SparkQuizSummaryProto {
    get {return _storage._summary ?? SparkQuizSummaryProto()}
    set {_uniqueStorage()._summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {return _storage._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {_uniqueStorage()._summary = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return _storage._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {_uniqueStorage()._expiresAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct SparkFirestoreStateProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var quizStates: Dictionary<String,SparkQuizStateProto> = [:]

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct SparkQuizStateProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var quizID: String = String()

  public var questionsAnswered: Int32 = 0

  public var questionsCorrect: Int32 = 0

  public var completed: Bool = false

  public var lastAnsweredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastAnsweredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastAnsweredAt = newValue}
  }
  /// Returns true if `lastAnsweredAt` has been explicitly set.
  public var hasLastAnsweredAt: Bool {return self._lastAnsweredAt != nil}
  /// Clears the value of `lastAnsweredAt`. Subsequent reads from it will return its default value.
  public mutating func clearLastAnsweredAt() {self._lastAnsweredAt = nil}

  public var score: Double = 0

  public var status: SparkQuizStateStatusProto = .undefined

  public var reviewStatus: SparkQuizReviewStatusProto = .undefined

  public var currentQuestionID: String = String()

  public var incorrectQuestionIds: [String] = []

  public var startedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startedAt = newValue}
  }
  /// Returns true if `startedAt` has been explicitly set.
  public var hasStartedAt: Bool {return self._startedAt != nil}
  /// Clears the value of `startedAt`. Subsequent reads from it will return its default value.
  public mutating func clearStartedAt() {self._startedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastAnsweredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _startedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct SparkSummarizeResponseProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var summary: SparkQuizSummaryProto {
    get {return _summary ?? SparkQuizSummaryProto()}
    set {_summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {return self._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {self._summary = nil}

  public var summarizedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _summarizedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_summarizedAt = newValue}
  }
  /// Returns true if `summarizedAt` has been explicitly set.
  public var hasSummarizedAt: Bool {return self._summarizedAt != nil}
  /// Clears the value of `summarizedAt`. Subsequent reads from it will return its default value.
  public mutating func clearSummarizedAt() {self._summarizedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _summary: SparkQuizSummaryProto? = nil
  fileprivate var _summarizedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct SparkQuizSummaryProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var quizID: String = String()

  public var headline: String = String()

  public var subjectBreakdown: [SparkSubjectSummaryProto] = []

  public var recommendations: [SparkStudyRecommendationProto] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkSubjectSummaryProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subject: SparkSubjectProto = .undefined

  public var masteryPercent: Double = 0

  public var narrative: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkStudyRecommendationProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var recommendationID: String = String()

  public var title: String = String()

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkApiErrorProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var message: String = String()

  public var details: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkRequestAuthProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var firebaseIDToken: String = String()

  public var appcheckToken: String = String()

  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkClientContextProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var apiVersion: String = String()

  public var clientVersion: String = String()

  public var device: SparkClientDeviceProto {
    get {return _device ?? SparkClientDeviceProto()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {self._device = nil}

  public var betaUser: Bool = false

  public var locale: SparkRequestLocaleProto {
    get {return _locale ?? SparkRequestLocaleProto()}
    set {_locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  public var hasLocale: Bool {return self._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  public mutating func clearLocale() {self._locale = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _device: SparkClientDeviceProto? = nil
  fileprivate var _locale: SparkRequestLocaleProto? = nil
}

public struct SparkClientDeviceProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platform: String = String()

  public var osVersion: String = String()

  public var deviceModel: String = String()

  public var isSimulator: Bool = false

  public var appBuild: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SparkRequestLocaleProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var language: String = String()

  public var region: String = String()

  public var timeZone: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SparkUploadTypeProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPARK_UPLOAD_TYPE_PROTO_UNDEFINED\0\u{1}SPARK_UPLOAD_TYPE_PROTO_PHOTO\0\u{1}SPARK_UPLOAD_TYPE_PROTO_PDF_FULL\0\u{1}SPARK_UPLOAD_TYPE_PROTO_PDF_PAGE_RANGE\0")
}

extension SparkAnswerGradeProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPARK_ANSWER_GRADE_PROTO_UNDEFINED\0\u{1}SPARK_ANSWER_GRADE_PROTO_CORRECT\0\u{1}SPARK_ANSWER_GRADE_PROTO_INCORRECT\0\u{1}SPARK_ANSWER_GRADE_PROTO_PARTIAL\0\u{1}SPARK_ANSWER_GRADE_PROTO_RETRY\0")
}

extension SparkQuestionKindProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPARK_QUESTION_KIND_PROTO_UNDEFINED\0\u{1}SPARK_QUESTION_KIND_PROTO_MULTIPLE_CHOICE\0\u{1}SPARK_QUESTION_KIND_PROTO_TRUE_FALSE\0\u{1}SPARK_QUESTION_KIND_PROTO_SHORT_TEXT\0\u{1}SPARK_QUESTION_KIND_PROTO_NUMERIC\0")
}

extension SparkNumericToleranceTypeProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPARK_NUMERIC_TOLERANCE_TYPE_PROTO_UNDEFINED\0\u{1}SPARK_NUMERIC_TOLERANCE_TYPE_PROTO_ABSOLUTE\0\u{1}SPARK_NUMERIC_TOLERANCE_TYPE_PROTO_RELATIVE\0")
}

extension SparkProgrammeProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPARK_PROGRAMME_PROTO_UNDEFINED\0\u{1}SPARK_PROGRAMME_PROTO_GCSE_TRIPLE_SCIENCE\0")
}

extension SparkSubjectProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPARK_SUBJECT_PROTO_UNDEFINED\0\u{1}SPARK_SUBJECT_PROTO_BIOLOGY\0\u{1}SPARK_SUBJECT_PROTO_CHEMISTRY\0\u{1}SPARK_SUBJECT_PROTO_PHYSICS\0")
}

extension SparkExamBoardProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPARK_EXAM_BOARD_PROTO_UNDEFINED\0\u{1}SPARK_EXAM_BOARD_PROTO_AQA\0\u{1}SPARK_EXAM_BOARD_PROTO_EDEXCEL\0\u{1}SPARK_EXAM_BOARD_PROTO_OCR\0")
}

extension SparkGenerationModeProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPARK_GENERATION_MODE_PROTO_UNDEFINED\0\u{1}SPARK_GENERATION_MODE_PROTO_EXTRACTION\0\u{1}SPARK_GENERATION_MODE_PROTO_SYNTHESIS\0")
}

extension SparkJobStateProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPARK_JOB_STATE_PROTO_UNDEFINED\0\u{1}SPARK_JOB_STATE_PROTO_RECEIVED\0\u{1}SPARK_JOB_STATE_PROTO_PROCESSING\0\u{1}SPARK_JOB_STATE_PROTO_COMPLETED\0\u{1}SPARK_JOB_STATE_PROTO_FAILED\0\u{1}SPARK_JOB_STATE_PROTO_CANCELLED\0")
}

extension SparkQuizStateStatusProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPARK_QUIZ_STATE_STATUS_PROTO_UNDEFINED\0\u{1}SPARK_QUIZ_STATE_STATUS_PROTO_NOT_STARTED\0\u{1}SPARK_QUIZ_STATE_STATUS_PROTO_IN_PROGRESS\0\u{1}SPARK_QUIZ_STATE_STATUS_PROTO_COMPLETED\0\u{1}SPARK_QUIZ_STATE_STATUS_PROTO_ARCHIVED\0")
}

extension SparkQuizReviewStatusProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPARK_QUIZ_REVIEW_STATUS_PROTO_UNDEFINED\0\u{1}SPARK_QUIZ_REVIEW_STATUS_PROTO_NOT_REQUIRED\0\u{1}SPARK_QUIZ_REVIEW_STATUS_PROTO_PENDING\0\u{1}SPARK_QUIZ_REVIEW_STATUS_PROTO_IN_REVIEW\0\u{1}SPARK_QUIZ_REVIEW_STATUS_PROTO_DONE\0")
}

extension SparkApiRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkApiRequestProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_auth\0\u{3}client_context\0\u{2}\u{8}create\0\u{3}check_answer\0")

  fileprivate class _StorageClass {
    var _requestAuth: SparkRequestAuthProto? = nil
    var _clientContext: SparkClientContextProto? = nil
    var _request: SparkApiRequestProto.OneOf_Request?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requestAuth = source._requestAuth
      _clientContext = source._clientContext
      _request = source._request
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._requestAuth) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._clientContext) }()
        case 10: try {
          var v: SparkCreateRequestProto?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .create(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .create(v)
          }
        }()
        case 11: try {
          var v: SparkCheckAnswerRequestProto?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .checkAnswer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .checkAnswer(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._requestAuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._clientContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      switch _storage._request {
      case .create?: try {
        guard case .create(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .checkAnswer?: try {
        guard case .checkAnswer(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkApiRequestProto, rhs: SparkApiRequestProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requestAuth != rhs_storage._requestAuth {return false}
        if _storage._clientContext != rhs_storage._clientContext {return false}
        if _storage._request != rhs_storage._request {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkApiResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkApiResponseProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}error\0\u{2}\u{9}create\0\u{3}check_answer\0\u{2}Y\u{1}latencies\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 10: try {
        var v: SparkCreateResponseProto?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .create(v)
        }
      }()
      case 11: try {
        var v: SparkCheckAnswerResponseProto?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .checkAnswer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .checkAnswer(v)
        }
      }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: &self.latencies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.response {
    case .create?: try {
      guard case .create(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .checkAnswer?: try {
      guard case .checkAnswer(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    if !self.latencies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: self.latencies, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkApiResponseProto, rhs: SparkApiResponseProto) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.response != rhs.response {return false}
    if lhs.latencies != rhs.latencies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkCreateRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkCreateRequestProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}upload\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._upload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._upload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkCreateRequestProto, rhs: SparkCreateRequestProto) -> Bool {
    if lhs._upload != rhs._upload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkCreateResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkCreateResponseProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}job\0\u{1}quiz\0")

  fileprivate class _StorageClass {
    var _job: SparkJobStatusProto? = nil
    var _quiz: SparkQuizProto? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _job = source._job
      _quiz = source._quiz
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._job) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._quiz) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._job {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._quiz {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkCreateResponseProto, rhs: SparkCreateResponseProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._job != rhs_storage._job {return false}
        if _storage._quiz != rhs_storage._quiz {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkUploadReferenceProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkUploadReferenceProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storage_path\0\u{3}upload_type\0\u{3}mime_type\0\u{3}size_bytes\0\u{3}page_range\0\u{3}uploaded_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.storagePath) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.uploadType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.sizeBytes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pageRange) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._uploadedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.storagePath.isEmpty {
      try visitor.visitSingularStringField(value: self.storagePath, fieldNumber: 1)
    }
    if self.uploadType != .undefined {
      try visitor.visitSingularEnumField(value: self.uploadType, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeBytes, fieldNumber: 4)
    }
    try { if let v = self._pageRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._uploadedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkUploadReferenceProto, rhs: SparkUploadReferenceProto) -> Bool {
    if lhs.storagePath != rhs.storagePath {return false}
    if lhs.uploadType != rhs.uploadType {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs._pageRange != rhs._pageRange {return false}
    if lhs._uploadedAt != rhs._uploadedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkPageRangeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkPageRangeProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_page\0\u{3}end_page\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.startPage) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.endPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startPage != 0 {
      try visitor.visitSingularInt32Field(value: self.startPage, fieldNumber: 1)
    }
    if self.endPage != 0 {
      try visitor.visitSingularInt32Field(value: self.endPage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkPageRangeProto, rhs: SparkPageRangeProto) -> Bool {
    if lhs.startPage != rhs.startPage {return false}
    if lhs.endPage != rhs.endPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkCheckAnswerRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkCheckAnswerRequestProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}quiz_id\0\u{3}question_id\0\u{1}answer\0\u{3}attempt_id\0\u{3}answered_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.quizID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.questionID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._answer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.attemptID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._answeredAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.quizID.isEmpty {
      try visitor.visitSingularStringField(value: self.quizID, fieldNumber: 1)
    }
    if !self.questionID.isEmpty {
      try visitor.visitSingularStringField(value: self.questionID, fieldNumber: 2)
    }
    try { if let v = self._answer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.attemptID.isEmpty {
      try visitor.visitSingularStringField(value: self.attemptID, fieldNumber: 4)
    }
    try { if let v = self._answeredAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkCheckAnswerRequestProto, rhs: SparkCheckAnswerRequestProto) -> Bool {
    if lhs.quizID != rhs.quizID {return false}
    if lhs.questionID != rhs.questionID {return false}
    if lhs._answer != rhs._answer {return false}
    if lhs.attemptID != rhs.attemptID {return false}
    if lhs._answeredAt != rhs._answeredAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkCheckAnswerResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkCheckAnswerResponseProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}evaluation\0\u{1}question\0\u{3}evaluated_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._evaluation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._question) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._evaluatedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._evaluation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._question {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._evaluatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkCheckAnswerResponseProto, rhs: SparkCheckAnswerResponseProto) -> Bool {
    if lhs._evaluation != rhs._evaluation {return false}
    if lhs._question != rhs._question {return false}
    if lhs._evaluatedAt != rhs._evaluatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkSubmittedAnswerProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkSubmittedAnswerProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{3}option_id\0\u{3}true_false\0\u{1}numeric\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .text(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .optionID(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .trueFalse(v)
        }
      }()
      case 4: try {
        var v: SparkNumericSubmissionProto?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .numeric(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .numeric(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .text?: try {
      guard case .text(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .optionID?: try {
      guard case .optionID(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .trueFalse?: try {
      guard case .trueFalse(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case .numeric?: try {
      guard case .numeric(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkSubmittedAnswerProto, rhs: SparkSubmittedAnswerProto) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkNumericSubmissionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkNumericSubmissionProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{1}unit\0\u{3}significant_figures\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.significantFigures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 2)
    }
    if self.significantFigures != 0 {
      try visitor.visitSingularInt32Field(value: self.significantFigures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkNumericSubmissionProto, rhs: SparkNumericSubmissionProto) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.significantFigures != rhs.significantFigures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkAnswerEvaluationProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkAnswerEvaluationProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}grade\0\u{1}feedback\0\u{1}score\0\u{3}retry_available_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.grade) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.feedback) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.score) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._retryAvailableAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.grade != .undefined {
      try visitor.visitSingularEnumField(value: self.grade, fieldNumber: 1)
    }
    if !self.feedback.isEmpty {
      try visitor.visitSingularStringField(value: self.feedback, fieldNumber: 2)
    }
    if self.score.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.score, fieldNumber: 3)
    }
    try { if let v = self._retryAvailableAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkAnswerEvaluationProto, rhs: SparkAnswerEvaluationProto) -> Bool {
    if lhs.grade != rhs.grade {return false}
    if lhs.feedback != rhs.feedback {return false}
    if lhs.score != rhs.score {return false}
    if lhs._retryAvailableAt != rhs._retryAvailableAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkQuestionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkQuestionProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}question_id\0\u{1}kind\0\u{1}prompt\0\u{1}source\0\u{3}answer_key\0\u{1}hints\0\u{3}created_at\0\u{4}\u{3}multiple_choice\0\u{3}true_false\0\u{3}short_text\0\u{1}numeric\0")

  fileprivate class _StorageClass {
    var _questionID: String = String()
    var _kind: SparkQuestionKindProto = .undefined
    var _prompt: String = String()
    var _source: SparkQuestionSourceProto? = nil
    var _answerKey: SparkQuestionAnswerKeyProto? = nil
    var _hints: [String] = []
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _body: SparkQuestionProto.OneOf_Body?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _questionID = source._questionID
      _kind = source._kind
      _prompt = source._prompt
      _source = source._source
      _answerKey = source._answerKey
      _hints = source._hints
      _createdAt = source._createdAt
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._questionID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._prompt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._source) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._answerKey) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._hints) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 10: try {
          var v: SparkMultipleChoiceQuestionProto?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .multipleChoice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .multipleChoice(v)
          }
        }()
        case 11: try {
          var v: SparkTrueFalseQuestionProto?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .trueFalse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .trueFalse(v)
          }
        }()
        case 12: try {
          var v: SparkFreeTextQuestionProto?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .shortText(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .shortText(v)
          }
        }()
        case 13: try {
          var v: SparkNumericQuestionProto?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .numeric(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .numeric(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._questionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._questionID, fieldNumber: 1)
      }
      if _storage._kind != .undefined {
        try visitor.visitSingularEnumField(value: _storage._kind, fieldNumber: 2)
      }
      if !_storage._prompt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._prompt, fieldNumber: 3)
      }
      try { if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._answerKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._hints.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._hints, fieldNumber: 6)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      switch _storage._body {
      case .multipleChoice?: try {
        guard case .multipleChoice(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .trueFalse?: try {
        guard case .trueFalse(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .shortText?: try {
        guard case .shortText(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .numeric?: try {
        guard case .numeric(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkQuestionProto, rhs: SparkQuestionProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._questionID != rhs_storage._questionID {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._prompt != rhs_storage._prompt {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._answerKey != rhs_storage._answerKey {return false}
        if _storage._hints != rhs_storage._hints {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkQuestionSourceProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkQuestionSourceProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}upload_path\0\u{3}page_range\0\u{1}snippet\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uploadPath) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pageRange) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.snippet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uploadPath.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadPath, fieldNumber: 1)
    }
    try { if let v = self._pageRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.snippet.isEmpty {
      try visitor.visitSingularStringField(value: self.snippet, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkQuestionSourceProto, rhs: SparkQuestionSourceProto) -> Bool {
    if lhs.uploadPath != rhs.uploadPath {return false}
    if lhs._pageRange != rhs._pageRange {return false}
    if lhs.snippet != rhs.snippet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkQuestionAnswerKeyProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkQuestionAnswerKeyProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}multiple_choice\0\u{3}true_false\0\u{3}short_text\0\u{1}numeric\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SparkMultipleChoiceAnswerKeyProto?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .multipleChoice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .multipleChoice(v)
        }
      }()
      case 2: try {
        var v: SparkTrueFalseAnswerKeyProto?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .trueFalse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .trueFalse(v)
        }
      }()
      case 3: try {
        var v: SparkFreeTextAnswerKeyProto?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .shortText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .shortText(v)
        }
      }()
      case 4: try {
        var v: SparkNumericAnswerKeyProto?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .numeric(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .numeric(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.key {
    case .multipleChoice?: try {
      guard case .multipleChoice(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .trueFalse?: try {
      guard case .trueFalse(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .shortText?: try {
      guard case .shortText(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .numeric?: try {
      guard case .numeric(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkQuestionAnswerKeyProto, rhs: SparkQuestionAnswerKeyProto) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkMultipleChoiceQuestionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkMultipleChoiceQuestionProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}options\0\u{3}shuffle_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.shuffleOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 1)
    }
    if self.shuffleOptions != false {
      try visitor.visitSingularBoolField(value: self.shuffleOptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkMultipleChoiceQuestionProto, rhs: SparkMultipleChoiceQuestionProto) -> Bool {
    if lhs.options != rhs.options {return false}
    if lhs.shuffleOptions != rhs.shuffleOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkMultipleChoiceOptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkMultipleChoiceOptionProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}option_id\0\u{1}text\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.optionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.optionID.isEmpty {
      try visitor.visitSingularStringField(value: self.optionID, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkMultipleChoiceOptionProto, rhs: SparkMultipleChoiceOptionProto) -> Bool {
    if lhs.optionID != rhs.optionID {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkTrueFalseQuestionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkTrueFalseQuestionProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}statement\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.statement) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statement.isEmpty {
      try visitor.visitSingularStringField(value: self.statement, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkTrueFalseQuestionProto, rhs: SparkTrueFalseQuestionProto) -> Bool {
    if lhs.statement != rhs.statement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkFreeTextQuestionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkFreeTextQuestionProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rubric\0\u{3}key_points\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rubric) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.keyPoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rubric {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.keyPoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keyPoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkFreeTextQuestionProto, rhs: SparkFreeTextQuestionProto) -> Bool {
    if lhs._rubric != rhs._rubric {return false}
    if lhs.keyPoints != rhs.keyPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkFreeTextRubricProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkFreeTextRubricProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}overview\0\u{3}bullet_points\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.overview) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.bulletPoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.overview.isEmpty {
      try visitor.visitSingularStringField(value: self.overview, fieldNumber: 1)
    }
    if !self.bulletPoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.bulletPoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkFreeTextRubricProto, rhs: SparkFreeTextRubricProto) -> Bool {
    if lhs.overview != rhs.overview {return false}
    if lhs.bulletPoints != rhs.bulletPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkNumericQuestionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkNumericQuestionProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}prompt_suffix\0\u{1}rule\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.promptSuffix) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.promptSuffix.isEmpty {
      try visitor.visitSingularStringField(value: self.promptSuffix, fieldNumber: 1)
    }
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkNumericQuestionProto, rhs: SparkNumericQuestionProto) -> Bool {
    if lhs.promptSuffix != rhs.promptSuffix {return false}
    if lhs._rule != rhs._rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkNumericAnswerRuleProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkNumericAnswerRuleProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{1}unit\0\u{3}tolerance_type\0\u{1}tolerance\0\u{3}significant_figures\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.toleranceType) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.tolerance) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.significantFigures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 2)
    }
    if self.toleranceType != .undefined {
      try visitor.visitSingularEnumField(value: self.toleranceType, fieldNumber: 3)
    }
    if self.tolerance.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.tolerance, fieldNumber: 4)
    }
    if self.significantFigures != 0 {
      try visitor.visitSingularInt32Field(value: self.significantFigures, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkNumericAnswerRuleProto, rhs: SparkNumericAnswerRuleProto) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.toleranceType != rhs.toleranceType {return false}
    if lhs.tolerance != rhs.tolerance {return false}
    if lhs.significantFigures != rhs.significantFigures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkMultipleChoiceAnswerKeyProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkMultipleChoiceAnswerKeyProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}correct_option_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.correctOptionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.correctOptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.correctOptionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkMultipleChoiceAnswerKeyProto, rhs: SparkMultipleChoiceAnswerKeyProto) -> Bool {
    if lhs.correctOptionID != rhs.correctOptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkTrueFalseAnswerKeyProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkTrueFalseAnswerKeyProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}correct_value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.correctValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.correctValue != false {
      try visitor.visitSingularBoolField(value: self.correctValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkTrueFalseAnswerKeyProto, rhs: SparkTrueFalseAnswerKeyProto) -> Bool {
    if lhs.correctValue != rhs.correctValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkFreeTextAnswerKeyProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkFreeTextAnswerKeyProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}exemplar_answers\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.exemplarAnswers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exemplarAnswers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exemplarAnswers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkFreeTextAnswerKeyProto, rhs: SparkFreeTextAnswerKeyProto) -> Bool {
    if lhs.exemplarAnswers != rhs.exemplarAnswers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkNumericAnswerKeyProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkNumericAnswerKeyProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}expected\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._expected) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expected {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkNumericAnswerKeyProto, rhs: SparkNumericAnswerKeyProto) -> Bool {
    if lhs._expected != rhs._expected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkQuizProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkQuizProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}quiz_id\0\u{1}metadata\0\u{1}questions\0\u{3}created_at\0\u{3}expires_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.quizID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.questions) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.quizID.isEmpty {
      try visitor.visitSingularStringField(value: self.quizID, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.questions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.questions, fieldNumber: 3)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkQuizProto, rhs: SparkQuizProto) -> Bool {
    if lhs.quizID != rhs.quizID {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.questions != rhs.questions {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkQuizMetadataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkQuizMetadataProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}programme\0\u{1}subject\0\u{3}exam_board\0\u{3}generation_mode\0\u{3}total_questions\0\u{1}topic\0\u{1}subtopic\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.programme) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subject) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.examBoard) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.generationMode) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.totalQuestions) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.subtopic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.programme != .undefined {
      try visitor.visitSingularEnumField(value: self.programme, fieldNumber: 1)
    }
    if self.subject != .undefined {
      try visitor.visitSingularEnumField(value: self.subject, fieldNumber: 2)
    }
    if self.examBoard != .undefined {
      try visitor.visitSingularEnumField(value: self.examBoard, fieldNumber: 3)
    }
    if self.generationMode != .undefined {
      try visitor.visitSingularEnumField(value: self.generationMode, fieldNumber: 4)
    }
    if self.totalQuestions != 0 {
      try visitor.visitSingularInt32Field(value: self.totalQuestions, fieldNumber: 5)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 6)
    }
    if !self.subtopic.isEmpty {
      try visitor.visitSingularStringField(value: self.subtopic, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkQuizMetadataProto, rhs: SparkQuizMetadataProto) -> Bool {
    if lhs.programme != rhs.programme {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.examBoard != rhs.examBoard {return false}
    if lhs.generationMode != rhs.generationMode {return false}
    if lhs.totalQuestions != rhs.totalQuestions {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.subtopic != rhs.subtopic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkJobStatusProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkJobStatusProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}job_id\0\u{1}state\0\u{3}progress_percent\0\u{3}status_message\0\u{3}updated_at\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.progressPercent) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.statusMessage) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    if self.state != .undefined {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    if self.progressPercent.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.progressPercent, fieldNumber: 3)
    }
    if !self.statusMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.statusMessage, fieldNumber: 4)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkJobStatusProto, rhs: SparkJobStatusProto) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.progressPercent != rhs.progressPercent {return false}
    if lhs.statusMessage != rhs.statusMessage {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkJobErrorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkJobErrorProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}context\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.context.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.context, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkJobErrorProto, rhs: SparkJobErrorProto) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.context != rhs.context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkFirestoreDocProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkFirestoreDocProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}doc_id\0\u{1}upload\0\u{1}job\0\u{1}quiz\0\u{1}summary\0\u{3}created_at\0\u{3}updated_at\0\u{3}expires_at\0")

  fileprivate class _StorageClass {
    var _docID: String = String()
    var _upload: SparkUploadReferenceProto? = nil
    var _job: SparkJobStatusProto? = nil
    var _quiz: SparkQuizProto? = nil
    var _summary: SparkQuizSummaryProto? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _docID = source._docID
      _upload = source._upload
      _job = source._job
      _quiz = source._quiz
      _summary = source._summary
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _expiresAt = source._expiresAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._docID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._upload) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._job) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._quiz) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._summary) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._expiresAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._docID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._docID, fieldNumber: 1)
      }
      try { if let v = _storage._upload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._job {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._quiz {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._summary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._expiresAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkFirestoreDocProto, rhs: SparkFirestoreDocProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._docID != rhs_storage._docID {return false}
        if _storage._upload != rhs_storage._upload {return false}
        if _storage._job != rhs_storage._job {return false}
        if _storage._quiz != rhs_storage._quiz {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._expiresAt != rhs_storage._expiresAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkFirestoreStateProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkFirestoreStateProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}quiz_states\0\u{3}updated_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SparkQuizStateProto>.self, value: &self.quizStates) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.quizStates.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SparkQuizStateProto>.self, value: self.quizStates, fieldNumber: 1)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkFirestoreStateProto, rhs: SparkFirestoreStateProto) -> Bool {
    if lhs.quizStates != rhs.quizStates {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkQuizStateProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkQuizStateProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}quiz_id\0\u{3}questions_answered\0\u{3}questions_correct\0\u{1}completed\0\u{3}last_answered_at\0\u{1}score\0\u{1}status\0\u{3}review_status\0\u{3}current_question_id\0\u{3}incorrect_question_ids\0\u{3}started_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.quizID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.questionsAnswered) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.questionsCorrect) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.completed) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastAnsweredAt) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.score) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.reviewStatus) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.currentQuestionID) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.incorrectQuestionIds) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._startedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.quizID.isEmpty {
      try visitor.visitSingularStringField(value: self.quizID, fieldNumber: 1)
    }
    if self.questionsAnswered != 0 {
      try visitor.visitSingularInt32Field(value: self.questionsAnswered, fieldNumber: 2)
    }
    if self.questionsCorrect != 0 {
      try visitor.visitSingularInt32Field(value: self.questionsCorrect, fieldNumber: 3)
    }
    if self.completed != false {
      try visitor.visitSingularBoolField(value: self.completed, fieldNumber: 4)
    }
    try { if let v = self._lastAnsweredAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.score.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.score, fieldNumber: 6)
    }
    if self.status != .undefined {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.reviewStatus != .undefined {
      try visitor.visitSingularEnumField(value: self.reviewStatus, fieldNumber: 8)
    }
    if !self.currentQuestionID.isEmpty {
      try visitor.visitSingularStringField(value: self.currentQuestionID, fieldNumber: 9)
    }
    if !self.incorrectQuestionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.incorrectQuestionIds, fieldNumber: 10)
    }
    try { if let v = self._startedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkQuizStateProto, rhs: SparkQuizStateProto) -> Bool {
    if lhs.quizID != rhs.quizID {return false}
    if lhs.questionsAnswered != rhs.questionsAnswered {return false}
    if lhs.questionsCorrect != rhs.questionsCorrect {return false}
    if lhs.completed != rhs.completed {return false}
    if lhs._lastAnsweredAt != rhs._lastAnsweredAt {return false}
    if lhs.score != rhs.score {return false}
    if lhs.status != rhs.status {return false}
    if lhs.reviewStatus != rhs.reviewStatus {return false}
    if lhs.currentQuestionID != rhs.currentQuestionID {return false}
    if lhs.incorrectQuestionIds != rhs.incorrectQuestionIds {return false}
    if lhs._startedAt != rhs._startedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkSummarizeResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkSummarizeResponseProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}summary\0\u{3}summarized_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._summary) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._summarizedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._summary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._summarizedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkSummarizeResponseProto, rhs: SparkSummarizeResponseProto) -> Bool {
    if lhs._summary != rhs._summary {return false}
    if lhs._summarizedAt != rhs._summarizedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkQuizSummaryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkQuizSummaryProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}quiz_id\0\u{1}headline\0\u{3}subject_breakdown\0\u{1}recommendations\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.quizID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.headline) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.subjectBreakdown) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.recommendations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quizID.isEmpty {
      try visitor.visitSingularStringField(value: self.quizID, fieldNumber: 1)
    }
    if !self.headline.isEmpty {
      try visitor.visitSingularStringField(value: self.headline, fieldNumber: 2)
    }
    if !self.subjectBreakdown.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subjectBreakdown, fieldNumber: 3)
    }
    if !self.recommendations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recommendations, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkQuizSummaryProto, rhs: SparkQuizSummaryProto) -> Bool {
    if lhs.quizID != rhs.quizID {return false}
    if lhs.headline != rhs.headline {return false}
    if lhs.subjectBreakdown != rhs.subjectBreakdown {return false}
    if lhs.recommendations != rhs.recommendations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkSubjectSummaryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkSubjectSummaryProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}subject\0\u{3}mastery_percent\0\u{1}narrative\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subject) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.masteryPercent) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.narrative) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subject != .undefined {
      try visitor.visitSingularEnumField(value: self.subject, fieldNumber: 1)
    }
    if self.masteryPercent.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.masteryPercent, fieldNumber: 2)
    }
    if !self.narrative.isEmpty {
      try visitor.visitSingularStringField(value: self.narrative, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkSubjectSummaryProto, rhs: SparkSubjectSummaryProto) -> Bool {
    if lhs.subject != rhs.subject {return false}
    if lhs.masteryPercent != rhs.masteryPercent {return false}
    if lhs.narrative != rhs.narrative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkStudyRecommendationProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkStudyRecommendationProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}recommendation_id\0\u{1}title\0\u{1}description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recommendationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recommendationID.isEmpty {
      try visitor.visitSingularStringField(value: self.recommendationID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkStudyRecommendationProto, rhs: SparkStudyRecommendationProto) -> Bool {
    if lhs.recommendationID != rhs.recommendationID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkApiErrorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkApiErrorProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}details\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitRepeatedStringField(value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkApiErrorProto, rhs: SparkApiErrorProto) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkRequestAuthProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkRequestAuthProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}firebase_id_token\0\u{3}appcheck_token\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.firebaseIDToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appcheckToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.firebaseIDToken.isEmpty {
      try visitor.visitSingularStringField(value: self.firebaseIDToken, fieldNumber: 1)
    }
    if !self.appcheckToken.isEmpty {
      try visitor.visitSingularStringField(value: self.appcheckToken, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkRequestAuthProto, rhs: SparkRequestAuthProto) -> Bool {
    if lhs.firebaseIDToken != rhs.firebaseIDToken {return false}
    if lhs.appcheckToken != rhs.appcheckToken {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkClientContextProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkClientContextProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}api_version\0\u{3}client_version\0\u{1}device\0\u{3}beta_user\0\u{1}locale\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.apiVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientVersion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.betaUser) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._locale) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.apiVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.apiVersion, fieldNumber: 1)
    }
    if !self.clientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.clientVersion, fieldNumber: 2)
    }
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.betaUser != false {
      try visitor.visitSingularBoolField(value: self.betaUser, fieldNumber: 4)
    }
    try { if let v = self._locale {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkClientContextProto, rhs: SparkClientContextProto) -> Bool {
    if lhs.apiVersion != rhs.apiVersion {return false}
    if lhs.clientVersion != rhs.clientVersion {return false}
    if lhs._device != rhs._device {return false}
    if lhs.betaUser != rhs.betaUser {return false}
    if lhs._locale != rhs._locale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkClientDeviceProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkClientDeviceProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}platform\0\u{3}os_version\0\u{3}device_model\0\u{3}is_simulator\0\u{3}app_build\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceModel) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isSimulator) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.appBuild) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 1)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 2)
    }
    if !self.deviceModel.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceModel, fieldNumber: 3)
    }
    if self.isSimulator != false {
      try visitor.visitSingularBoolField(value: self.isSimulator, fieldNumber: 4)
    }
    if !self.appBuild.isEmpty {
      try visitor.visitSingularStringField(value: self.appBuild, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkClientDeviceProto, rhs: SparkClientDeviceProto) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.deviceModel != rhs.deviceModel {return false}
    if lhs.isSimulator != rhs.isSimulator {return false}
    if lhs.appBuild != rhs.appBuild {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SparkRequestLocaleProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SparkRequestLocaleProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}language\0\u{1}region\0\u{3}time_zone\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timeZone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 1)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 2)
    }
    if !self.timeZone.isEmpty {
      try visitor.visitSingularStringField(value: self.timeZone, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SparkRequestLocaleProto, rhs: SparkRequestLocaleProto) -> Bool {
    if lhs.language != rhs.language {return false}
    if lhs.region != rhs.region {return false}
    if lhs.timeZone != rhs.timeZone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
